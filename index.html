<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>戦術比較シミュレーター</title>
  <style>
    :root {
      --bg: #1f5fbf;
      --card: rgba(255,255,255,0.06);
      --text: #ffffff;
      --line: rgba(255,255,255,0.18);
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: "Helvetica Neue", Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    .wrap { max-width: 1100px; margin: 20px auto; padding: 0 16px 60px; }
    h1 { font-size: 20px; margin-bottom: 10px; border-left: 5px solid #fff; padding-left: 10px; }

    .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 15px;
      backdrop-filter: blur(6px);
      margin-bottom: 15px;
    }

    .row { display: grid; gap: 10px; margin-bottom: 10px; }
    .two { grid-template-columns: 1fr 1fr; }
    .three { grid-template-columns: 1fr 1fr 1fr; }

    label { display: block; font-size: 11px; margin-bottom: 4px; opacity: 0.85; font-weight: bold;}
    input, select, button {
      width: 100%; padding: 6px; border-radius: 4px; border: 1px solid var(--line);
      background: rgba(0,0,0,0.3); color: #fff; box-sizing: border-box; font-size: 13px;
    }
    button { background: rgba(255,255,255,0.15); cursor: pointer; font-weight: bold; padding: 10px; }
    button:hover { background: rgba(255,255,255,0.25); }
    button:disabled { opacity: 0.6; cursor: not-allowed; }

    .table-scroll { overflow-x: auto; }
    .lineup-table { width: 100%; border-collapse: collapse; min-width: 620px; }
    .lineup-table th { text-align: left; font-size: 11px; color: #ddd; border-bottom: 1px solid var(--line); padding: 4px; }
    .lineup-table td { padding: 4px; border-bottom: 1px solid rgba(255,255,255,0.05); }
    .lineup-row:hover { background: rgba(255,255,255,0.05); }

    .result-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    .result-table th, .result-table td {
      border: 1px solid var(--line); padding: 8px; text-align: center; font-size: 13px;
    }
    .result-table th { background: rgba(0,0,0,0.3); }

    .title { font-weight: bold; margin-bottom: 8px; font-size: 14px; border-bottom: 1px solid var(--line); padding-bottom: 4px; color: #eee;}
    .hint { font-size: 11px; opacity: 0.75; margin-top: 6px; line-height: 1.6; }
    .loading { color: #ffeebb; font-weight: bold; display: none; margin-top:10px;}
    .mini { font-size: 11px; opacity: 0.75; margin-top: 6px; line-height: 1.6; }

    .current-batter-row { background: rgba(255, 255, 100, 0.2) !important; }
    .runner-select-box { display: none; margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px;}
    .runner-select-box.active { display: block; }

    .disabled-note { font-size: 11px; opacity: 0.75; margin-top: 6px; line-height: 1.6; }

    .progress-wrap {
      margin-top: 10px;
      border: 1px solid var(--line);
      border-radius: 8px;
      overflow: hidden;
      height: 10px;
      background: rgba(0,0,0,0.25);
      display: none;
    }
    .progress-bar {
      height: 100%;
      width: 0%;
      background: rgba(255,255,255,0.35);
    }
  </style>
</head>
<body>
<div class="wrap">
  <h1>戦術比較シミュレーター</h1>

  <div class="card">
    <div class="title">1. 打者の設定</div>

    <div class="row two">
      <div>
        <label>入力モード</label>
        <select id="batterMode">
          <option value="triple" selected>打率 出塁率 長打率</option>
          <option value="ops">OPS</option>
        </select>
      </div>
      <div>
        <label>補足</label>
        <div class="mini" id="batterModeHint">
          打率 出塁率 長打率を分けると打者タイプの差が出やすくなります
        </div>
      </div>
    </div>

    <div class="hint">
      走力は進塁とアウト時の進塁と盗塁死と併殺の起きやすさに影響します。入力モードがOPSの場合は内部で出塁率と長打率を推定します。
    </div>

    <div class="table-scroll" style="margin-top:10px;">
      <table class="lineup-table">
        <thead id="lineupHead"></thead>
        <tbody id="lineupBody"></tbody>
      </table>
    </div>
  </div>

  <div class="card">
    <div class="title">2. シチュエーション設定</div>

    <div class="row two">
      <div>
        <label>相手投手のレベル</label>
        <select id="pitcherLevel">
          <option value="ace">エース級 (防御率2.5以下)</option>
          <option value="normal" selected>平均的 (防御率2.6~4.0)</option>
          <option value="weak">格下 (防御率4.1以上)</option>
        </select>
      </div>
      <div>
        <label>シミュレーション回数</label>
        <select id="simCount">
          <option value="100">百回</option>
          <option value="1000">千回</option>
          <option value="10000">1万回</option>
          <option value="100000" selected>10万回</option>
        </select>
      </div>
    </div>

    <div class="row three">
      <div>
        <label>アウトカウント</label>
        <select id="outs">
          <option value="0" selected>0アウト</option>
          <option value="1">1アウト</option>
          <option value="2">2アウト</option>
        </select>
      </div>

      <div>
        <label>現在の打者</label>
        <select id="currentBatterIndex">
          <option value="0">1番打者</option>
          <option value="1">2番打者</option>
          <option value="2">3番打者</option>
          <option value="3" selected>4番打者</option>
          <option value="4">5番打者</option>
          <option value="5">6番打者</option>
          <option value="6">7番打者</option>
          <option value="7">8番打者</option>
          <option value="8">9番打者</option>
        </select>
      </div>

      <div>
        <label>エンドラン適性</label>
        <select id="endrunSkill">
          <option value="low">低い</option>
          <option value="normal" selected>普通</option>
          <option value="high">高い</option>
        </select>
        <div class="mini" id="endrunNote">エンドランは1塁か2塁の走者だけがスタートします</div>
      </div>
    </div>

    <div class="row">
      <div>
        <label>塁状況 ベース</label>
        <select id="runnersScenario">
          <option value="0" selected>走者なし</option>
          <option value="1">1塁</option>
          <option value="2">2塁</option>
          <option value="3">3塁</option>
          <option value="12">1 2塁</option>
          <option value="13">1 3塁</option>
          <option value="23">2 3塁</option>
          <option value="123">満塁</option>
        </select>
      </div>
    </div>

    <div id="runnerSelectorArea" class="runner-select-box">
      <label>ランナー指定 走力に影響</label>
      <div class="row three">
        <div id="r3_box" style="visibility:hidden;">
          <label>3塁走者</label>
          <select id="runner3_idx" class="runner-dd"></select>
        </div>
        <div id="r2_box" style="visibility:hidden;">
          <label>2塁走者</label>
          <select id="runner2_idx" class="runner-dd"></select>
        </div>
        <div id="r1_box" style="visibility:hidden;">
          <label>1塁走者</label>
          <select id="runner1_idx" class="runner-dd"></select>
        </div>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="title">3. 戦術成功率パラメータ</div>
    <div class="row three">
      <div>
        <label>送りバント成功率 パーセント</label>
        <input type="number" id="buntRate" value="0" min="0" max="100">
      </div>
      <div>
        <label>盗塁成功率 パーセント</label>
        <input type="number" id="stealRate" value="0" min="0" max="100">
      </div>
      <div>
        <label>スクイズ成功率 パーセント</label>
        <input type="number" id="sqRate" value="0" min="0" max="100">
      </div>
    </div>

    <div id="paramNote" class="disabled-note"></div>

    <div class="hint">
      エンドランは成功率入力を使わずに自動で挙動が変わります。エンドラン中は空振りが減りやすくなりゴロが増えやすくなり併殺が起きにくくなります。空振り三振のときは走者が刺される可能性がありますが俊足ほど刺されにくくなります。
    </div>

    <div style="margin-top:15px;">
      <button id="calcBtn">分析実行</button>
      <div id="loading" class="loading">シミュレーション実行中</div>
      <div id="progressWrap" class="progress-wrap"><div id="progressBar" class="progress-bar"></div></div>
      <div id="progressText" class="mini" style="display:none;"></div>
    </div>
  </div>

  <div class="card">
    <div class="results" id="output">
      <div class="title">分析結果</div>
      <div style="padding:10px; font-size:13px; opacity:0.85; line-height:1.7;">
        得点期待値はこの回の攻撃で取れる平均得点です。得点確率はこの回の攻撃で1点以上取る確率です。目標得点別は1点だけや2点だけの確率で比べます。
      </div>
    </div>
  </div>
</div>

<script>
  const clamp = (x, lo, hi) => Math.max(lo, Math.min(hi, x));

  const defaultTripleLineup = [
    { avg: 0.290, obp: 0.360, slg: 0.410, spd: "fast" },
    { avg: 0.280, obp: 0.330, slg: 0.380, spd: "normal" },
    { avg: 0.310, obp: 0.390, slg: 0.550, spd: "normal" },
    { avg: 0.270, obp: 0.350, slg: 0.600, spd: "slow" },
    { avg: 0.260, obp: 0.320, slg: 0.450, spd: "normal" },
    { avg: 0.250, obp: 0.310, slg: 0.380, spd: "fast" },
    { avg: 0.240, obp: 0.290, slg: 0.340, spd: "normal" },
    { avg: 0.210, obp: 0.250, slg: 0.280, spd: "normal" },
    { avg: 0.150, obp: 0.180, slg: 0.180, spd: "slow" }
  ];

  let activeWorker = null;

  function runnersStrToBits(s) {
    if (s === "0") return 0;
    let b = 0;
    if (s.includes("1")) b |= 4;
    if (s.includes("2")) b |= 2;
    if (s.includes("3")) b |= 1;
    return b;
  }

  function bitsToHas(bits) {
    return {
      has1: (bits & 4) !== 0,
      has2: (bits & 2) !== 0,
      has3: (bits & 1) !== 0
    };
  }

  function chooseStealTargetBits(runners) {
    const { has1, has2, has3 } = bitsToHas(runners);
    if (has2 && !has3) return { bitFrom: 2, bitTo: 1, baseFrom: 2, baseTo: 3 };
    if (has1 && !has2) return { bitFrom: 4, bitTo: 2, baseFrom: 1, baseTo: 2 };
    return null;
  }

  function updateEndrunNote() {
    const bits = runnersStrToBits(document.getElementById("runnersScenario").value);
    const t = chooseStealTargetBits(bits);
    const el = document.getElementById("endrunNote");
    if (!t) {
      el.textContent = "今の塁状況だとエンドランは分析に出ません";
      return;
    }
    if (t.baseFrom === 1) {
      el.textContent = "エンドランの走者は1塁です。1 3塁でも1塁走者だけがスタートします";
    } else {
      el.textContent = "エンドランの走者は2塁です。1塁走者はスタートしません";
    }
  }

  function highlightCurrentBatter() {
    const idx = document.getElementById("currentBatterIndex").value;
    document.querySelectorAll(".lineup-row").forEach(r => r.classList.remove("current-batter-row"));
    const row = document.getElementById("batterRow" + idx);
    if (row) row.classList.add("current-batter-row");
  }

  function updateAvailabilityOnly() {
    const outs = parseInt(document.getElementById("outs").value, 10);
    const bits = runnersStrToBits(document.getElementById("runnersScenario").value);

    const buntInp = document.getElementById("buntRate");
    const stealInp = document.getElementById("stealRate");
    const sqInp = document.getElementById("sqRate");
    const note = document.getElementById("paramNote");

    const hasR = bits !== 0;
    const has3 = (bits & 1) !== 0;

    const canBunt = hasR && outs < 2;
    const canSq = has3 && outs < 2;
    const canSteal = chooseStealTargetBits(bits) !== null;

    buntInp.disabled = !canBunt;
    sqInp.disabled = !canSq;

    if (!canBunt) buntInp.value = 0;
    if (!canSq) sqInp.value = 0;

    stealInp.disabled = false;

    let msg = "";
    if (!canBunt) msg += "送りバントは走者ありで2アウト以外のときだけ分析に出ます。";
    if (msg !== "") msg += " ";
    if (!canSteal) msg += "盗塁とエンドランは1塁走者がいて2塁が空きか2塁走者がいて3塁が空きのときだけ分析に出ます。";
    if (msg !== "") msg += " ";
    if (!canSq) msg += "スクイズは3塁走者ありで2アウト以外のときだけ分析に出ます。";
    note.textContent = msg.trim();

    updateEndrunNote();
  }

  function updateRunnerSelectVisibility() {
    const scen = document.getElementById("runnersScenario").value;
    const area = document.getElementById("runnerSelectorArea");

    if (scen === "0") area.classList.remove("active");
    else area.classList.add("active");

    const r1 = document.getElementById("r1_box");
    const r2 = document.getElementById("r2_box");
    const r3 = document.getElementById("r3_box");

    r1.style.visibility = scen.includes("1") ? "visible" : "hidden";
    r2.style.visibility = scen.includes("2") ? "visible" : "hidden";
    r3.style.visibility = scen.includes("3") ? "visible" : "hidden";

    const curIdx = parseInt(document.getElementById("currentBatterIndex").value, 10);
    let offset = 1;

    if (r1.style.visibility === "visible") {
      document.getElementById("runner1_idx").value = (curIdx - offset + 9) % 9;
      offset++;
    }
    if (r2.style.visibility === "visible") {
      document.getElementById("runner2_idx").value = (curIdx - offset + 9) % 9;
      offset++;
    }
    if (r3.style.visibility === "visible") {
      document.getElementById("runner3_idx").value = (curIdx - offset + 9) % 9;
      offset++;
    }

    updateAvailabilityOnly();
  }

  function updateBatterModeHint() {
    const mode = document.getElementById("batterMode").value;
    const el = document.getElementById("batterModeHint");
    if (mode === "triple") el.textContent = "打率 出塁率 長打率を分けると打者タイプの差が出やすくなります";
    else el.textContent = "OPSは入力が簡単ですが同じOPSでも中身の違いは表現しにくいです";
  }

  function deriveFromOPS(ops) {
    ops = clamp(ops, 0.250, 1.300);

    let obp = ops * 0.45 + 0.02;
    obp = clamp(obp, 0.200, 0.450);

    let slg = ops - obp;
    slg = clamp(slg, 0.250, 0.850);

    obp = clamp(ops - slg, 0.200, 0.450);
    slg = clamp(ops - obp, 0.250, 0.850);

    let bb = 0.06 + (ops - 0.700) * 0.08;
    bb = clamp(bb, 0.03, 0.14);

    let avg = obp - bb;
    avg = clamp(avg, 0.170, 0.360);
    avg = Math.min(avg, obp);

    return { avg, obp, slg };
  }

  function readLineupNormalized() {
    const mode = document.getElementById("batterMode").value;
    const arr = [];

    document.querySelectorAll(".lineup-row").forEach(row => {
      const spd = row.querySelector(".spd-inp").value;

      if (mode === "triple") {
        let avg = parseFloat(row.querySelector(".avg-inp").value);
        let obp = parseFloat(row.querySelector(".obp-inp").value);
        let slg = parseFloat(row.querySelector(".slg-inp").value);

        if (!isFinite(avg)) avg = 0.250;
        if (!isFinite(obp)) obp = 0.320;
        if (!isFinite(slg)) slg = 0.380;

        avg = clamp(avg, 0.120, 0.420);
        obp = clamp(obp, 0.150, 0.500);
        slg = clamp(slg, 0.150, 0.900);

        if (obp < avg) obp = avg;
        if (slg < avg) slg = avg;

        arr.push({ avg, obp, slg, spd });

      } else {
        let ops = parseFloat(row.querySelector(".ops-inp").value);
        if (!isFinite(ops)) ops = 0.700;
        const b = deriveFromOPS(ops);
        arr.push({ ...b, spd });
      }
    });

    return arr;
  }

  function renderLineupTable() {
    const mode = document.getElementById("batterMode").value;

    const head = document.getElementById("lineupHead");
    const tbody = document.getElementById("lineupBody");

    const current = readLineupNormalizedSafeForRerender();

    let theadHTML = "";
    if (mode === "triple") {
      theadHTML = `
        <tr>
          <th style="width:30px;">打順</th>
          <th>打率</th>
          <th>出塁率</th>
          <th>長打率</th>
          <th>走力</th>
        </tr>
      `;
    } else {
      theadHTML = `
        <tr>
          <th style="width:30px;">打順</th>
          <th>OPS</th>
          <th>走力</th>
        </tr>
      `;
    }

    head.innerHTML = theadHTML;

    let options = "";
    for (let i = 0; i < 9; i++) options += `<option value="${i}">${i + 1}番</option>`;

    let rowsHTML = "";
    for (let i = 0; i < 9; i++) {
      const d = current[i] || defaultTripleLineup[i];
      const ops = (d.obp + d.slg);

      if (mode === "triple") {
        rowsHTML += `
          <tr class="lineup-row" id="batterRow${i}">
            <td style="text-align:center; font-weight:bold;">${i + 1}</td>
            <td><input type="number" step="0.001" min="0" max="1" value="${d.avg.toFixed(3)}" class="avg-inp"></td>
            <td><input type="number" step="0.001" min="0" max="1" value="${d.obp.toFixed(3)}" class="obp-inp"></td>
            <td><input type="number" step="0.001" min="0" max="1.5" value="${d.slg.toFixed(3)}" class="slg-inp"></td>
            <td>
              <select class="spd-inp">
                <option value="normal" ${d.spd === "normal" ? "selected" : ""}>普通</option>
                <option value="fast" ${d.spd === "fast" ? "selected" : ""}>俊足</option>
                <option value="slow" ${d.spd === "slow" ? "selected" : ""}>鈍足</option>
              </select>
            </td>
          </tr>
        `;
      } else {
        rowsHTML += `
          <tr class="lineup-row" id="batterRow${i}">
            <td style="text-align:center; font-weight:bold;">${i + 1}</td>
            <td><input type="number" step="0.001" min="0" max="2" value="${ops.toFixed(3)}" class="ops-inp"></td>
            <td>
              <select class="spd-inp">
                <option value="normal" ${d.spd === "normal" ? "selected" : ""}>普通</option>
                <option value="fast" ${d.spd === "fast" ? "selected" : ""}>俊足</option>
                <option value="slow" ${d.spd === "slow" ? "selected" : ""}>鈍足</option>
              </select>
            </td>
          </tr>
        `;
      }
    }

    tbody.innerHTML = rowsHTML;
    document.querySelectorAll(".runner-dd").forEach(s => s.innerHTML = options);

    highlightCurrentBatter();
    updateRunnerSelectVisibility();
    updateBatterModeHint();
  }

  function readLineupNormalizedSafeForRerender() {
    const tbody = document.getElementById("lineupBody");
    if (!tbody || tbody.children.length === 0) {
      return defaultTripleLineup.map(x => ({ ...x }));
    }

    try {
      return readLineupNormalized();
    } catch (e) {
      return defaultTripleLineup.map(x => ({ ...x }));
    }
  }

  function buildStrategies(startOuts, startRunners) {
    const strategies = [
      { id: "normal", name: "強攻", type: "normal", rate: 0 }
    ];

    const buntRate = parseFloat(document.getElementById("buntRate").value) / 100;
    const stealRate = parseFloat(document.getElementById("stealRate").value) / 100;
    const sqRate = parseFloat(document.getElementById("sqRate").value) / 100;

    const has3 = (startRunners & 1) !== 0;
    const stealTarget = chooseStealTargetBits(startRunners);

    if (startRunners !== 0 && startOuts < 2 && buntRate > 0) {
      strategies.push({ id: "bunt", name: "バント", type: "bunt", rate: buntRate });
    }

    if (stealTarget && startOuts < 2) {
      strategies.push({ id: "endrun", name: "エンドラン", type: "endrun", rate: 0 });
    }

    if (stealTarget && stealRate > 0 && startOuts < 2) {
      strategies.push({ id: "steal", name: "盗塁", type: "steal", rate: stealRate });
    }

    if (has3 && startOuts < 2 && sqRate > 0) {
      strategies.push({ id: "sq", name: "スクイズ", type: "squeeze", rate: sqRate });
    }

    return strategies;
  }

  function createSimWorker() {
    const workerCode = `
      function clamp(x, lo, hi) { return Math.max(lo, Math.min(hi, x)); }

      function mulberry32(seed) {
        let t = seed >>> 0;
        return function() {
          t += 0x6D2B79F5;
          let r = Math.imul(t ^ (t >>> 15), 1 | t);
          r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
          return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
        };
      }

      function chooseStealTarget(runners) {
        const has1 = (runners & 4) !== 0;
        const has2 = (runners & 2) !== 0;
        const has3 = (runners & 1) !== 0;
        if (has2 && !has3) return { bitFrom: 2, bitTo: 1, baseFrom: 2, baseTo: 3 };
        if (has1 && !has2) return { bitFrom: 4, bitTo: 2, baseFrom: 1, baseTo: 2 };
        return null;
      }

      function spdToNum(spd) {
        if (spd === 'fast') return 1;
        if (spd === 'slow') return -1;
        return 0;
      }

      function pitcherStealAdj(pitcherLevel) {
        if (pitcherLevel === 'ace') return -0.05;
        if (pitcherLevel === 'weak') return 0.03;
        return 0.0;
      }

      function endrunKAdj(endrunSkill) {
        if (endrunSkill === 'high') return 0.65;
        if (endrunSkill === 'low') return 1.35;
        return 1.0;
      }

      function endrunContactAdj(endrunSkill) {
        if (endrunSkill === 'high') return 1.10;
        if (endrunSkill === 'low') return 0.98;
        return 1.05;
      }

      function makeBatterProbs(b, pitcherLevel, isEndRun, endrunSkill) {
        let avg = b.avg;
        let obp = b.obp;
        let slg = b.slg;

        let factor = 1.0;
        if (pitcherLevel === 'ace') factor = 0.90;
        if (pitcherLevel === 'weak') factor = 1.10;

        avg = clamp(avg, 0.10, 0.45);
        obp = clamp(obp, avg, 0.55);
        slg = clamp(slg, avg, 1.00);

        let bbRate = (obp - avg) * factor;
        if (bbRate < 0) bbRate = 0;

        let hitRate = avg * factor;
        hitRate = clamp(hitRate, 0, 0.60);

        let iso = (slg - avg) * factor;
        if (iso < 0) iso = 0;

        let tripleRate = 0.004 + (spdToNum(b.spd) === 1 ? 0.010 : (spdToNum(b.spd) === -1 ? -0.002 : 0));
        tripleRate = clamp(tripleRate, 0.001, 0.020);

        let hrRate = iso * 0.24;
        hrRate = clamp(hrRate, 0, 0.10);

        let doubleRate = iso * 0.72 - hrRate;
        if (doubleRate < 0) doubleRate = 0.005;
        doubleRate = clamp(doubleRate, 0, 0.20);

        let singleRate = hitRate - hrRate - tripleRate - doubleRate;
        if (singleRate < 0) singleRate = 0;
        singleRate = clamp(singleRate, 0, 0.45);

        if (isEndRun) {
          const cAdj = endrunContactAdj(endrunSkill);
          bbRate *= 0.55;
          hrRate *= 0.18;
          doubleRate *= 0.85;
          tripleRate *= 0.85;
          singleRate *= (1.05 * cAdj);
        }

        let sumHit = hrRate + tripleRate + doubleRate + singleRate;

        let sum = sumHit + bbRate;
        if (sum > 0.95) {
          const scale = 0.95 / sum;
          hrRate *= scale;
          tripleRate *= scale;
          doubleRate *= scale;
          singleRate *= scale;
          bbRate *= scale;
          sumHit = hrRate + tripleRate + doubleRate + singleRate;
          sum = sumHit + bbRate;
        }

        let remaining = 1.0 - sum;
        if (remaining < 0) remaining = 0;

        let kShare = 0.20 + (slg - 0.380) * 0.25;
        kShare = clamp(kShare, 0.12, 0.30);

        if (isEndRun) {
          kShare *= 0.72 * endrunKAdj(endrunSkill);
          kShare = clamp(kShare, 0.06, 0.30);
        }

        let kRate = remaining * kShare;
        kRate = clamp(kRate, 0, remaining);

        let inplayOut = remaining - kRate;
        if (inplayOut < 0) inplayOut = 0;

        let gbShare = 0.46;
        let ldShare = 0.12;
        let fbShare = 1.0 - gbShare - ldShare;

        if (isEndRun) {
          gbShare = 0.60;
          ldShare = 0.10;
          fbShare = 0.30;
        }

        let gbOut = inplayOut * gbShare;
        let ldOut = inplayOut * ldShare;
        let fbOut = inplayOut * fbShare;

        let dist = [];
        let c = 0;

        c += hrRate; dist.push([c, 'HR']);
        c += tripleRate; dist.push([c, '3B']);
        c += doubleRate; dist.push([c, '2B']);
        c += singleRate; dist.push([c, '1B']);
        c += bbRate; dist.push([c, 'BB']);
        c += kRate; dist.push([c, 'K']);
        c += gbOut; dist.push([c, 'GB']);
        c += ldOut; dist.push([c, 'LD']);
        c += fbOut; dist.push([c, 'FB']);
        dist.push([1.0, 'OUT']);

        return dist;
      }

      function pick(dist, rnd) {
        const r = rnd();
        for (let i = 0; i < dist.length; i++) {
          if (r < dist[i][0]) return dist[i][1];
        }
        return 'OUT';
      }

      function stealSuccessProb(baseRate, runnerSpd, pitcherLevel) {
        let p = baseRate;
        if (runnerSpd === 'fast') p += 0.10;
        if (runnerSpd === 'slow') p -= 0.10;
        p += pitcherStealAdj(pitcherLevel);
        return clamp(p, 0.05, 0.95);
      }

      function endrunCaughtProb(target, runnerSpd, pitcherLevel, endrunSkill) {
        if (!target) return 0.0;

        let baseSuccess = (target.baseFrom === 2) ? 0.75 : 0.65;
        if (runnerSpd === 'fast') baseSuccess += 0.08;
        if (runnerSpd === 'slow') baseSuccess -= 0.08;

        baseSuccess += pitcherStealAdj(pitcherLevel) * 0.6;

        if (endrunSkill === 'high') baseSuccess += 0.02;
        if (endrunSkill === 'low') baseSuccess -= 0.03;

        baseSuccess -= 0.08;

        baseSuccess = clamp(baseSuccess, 0.05, 0.95);
        return clamp(1.0 - baseSuccess, 0.05, 0.95);
      }

      function advOnHit(runners, event, batterSpd, runnerSpeeds, outs, isEndRun, rnd) {
        const r1 = (runners & 4) !== 0;
        const r2 = (runners & 2) !== 0;
        const r3 = (runners & 1) !== 0;

        let runs = 0;
        let nextR = 0;
        let nextS = {};

        function outAggBonus() {
          if (outs >= 2) return 0.10;
          if (outs === 1) return 0.04;
          return 0.0;
        }

        if (event === 'HR') {
          runs = 1 + (r1?1:0) + (r2?1:0) + (r3?1:0);
          return { runs: runs, outsAdded: 0, nextRunners: 0, nextRunnerSpeeds: {} };
        }

        if (event === '3B') {
          runs = (r1?1:0) + (r2?1:0) + (r3?1:0);
          nextR = 1;
          nextS[3] = batterSpd;
          return { runs: runs, outsAdded: 0, nextRunners: nextR, nextRunnerSpeeds: nextS };
        }

        if (event === '2B') {
          if (r3) runs += 1;
          if (r2) runs += 1;

          if (r1) {
            let p = 0.35 + outAggBonus();
            if (runnerSpeeds[1] === 'fast') p += 0.18;
            if (runnerSpeeds[1] === 'slow') p -= 0.14;
            if (isEndRun) p += 0.06;
            p = clamp(p, 0.05, 0.90);

            if (rnd() < p) {
              runs += 1;
            } else {
              nextR |= 1;
              nextS[3] = runnerSpeeds[1];
            }
          }

          nextR |= 2;
          nextS[2] = batterSpd;

          return { runs: runs, outsAdded: 0, nextRunners: nextR, nextRunnerSpeeds: nextS };
        }

        if (event === '1B') {
          if (r3) runs += 1;

          if (r2) {
            let p = 0.45 + outAggBonus();
            if (runnerSpeeds[2] === 'fast') p += 0.20;
            if (runnerSpeeds[2] === 'slow') p -= 0.18;
            if (isEndRun) p += 0.06;
            p = clamp(p, 0.05, 0.95);

            if (rnd() < p) {
              runs += 1;
            } else {
              nextR |= 1;
              nextS[3] = runnerSpeeds[2];
            }
          }

          if (r1) {
            let p3 = 0.10 + outAggBonus();
            if (runnerSpeeds[1] === 'fast') p3 += 0.12;
            if (runnerSpeeds[1] === 'slow') p3 -= 0.06;
            if (isEndRun) p3 += 0.12;
            p3 = clamp(p3, 0.02, 0.60);

            if (rnd() < p3) {
              if ((nextR & 1) === 0) {
                nextR |= 1;
                nextS[3] = runnerSpeeds[1];
              } else {
                nextR |= 2;
                nextS[2] = runnerSpeeds[1];
              }
            } else {
              nextR |= 2;
              nextS[2] = runnerSpeeds[1];
            }
          }

          nextR |= 4;
          nextS[1] = batterSpd;

          return { runs: runs, outsAdded: 0, nextRunners: nextR, nextRunnerSpeeds: nextS };
        }

        if (event === 'BB') {
          if (r1 && r2 && r3) {
            runs += 1;
            nextR = 7;
            nextS[3] = runnerSpeeds[3];
            nextS[2] = runnerSpeeds[2];
            nextS[1] = runnerSpeeds[1];
            return { runs: runs, outsAdded: 0, nextRunners: nextR, nextRunnerSpeeds: nextS };
          }

          if (r2 && r3 && !r1) {
            nextR = 7;
            nextS[3] = runnerSpeeds[3];
            nextS[2] = runnerSpeeds[2];
            nextS[1] = batterSpd;
            return { runs: runs, outsAdded: 0, nextRunners: nextR, nextRunnerSpeeds: nextS };
          }

          if (r1 && r3 && !r2) {
            nextR = 7;
            nextS[3] = runnerSpeeds[3];
            nextS[2] = runnerSpeeds[1];
            nextS[1] = batterSpd;
            return { runs: runs, outsAdded: 0, nextRunners: nextR, nextRunnerSpeeds: nextS };
          }

          if (r1 && r2 && !r3) {
            nextR = 7;
            nextS[3] = runnerSpeeds[2];
            nextS[2] = runnerSpeeds[1];
            nextS[1] = batterSpd;
            return { runs: runs, outsAdded: 0, nextRunners: nextR, nextRunnerSpeeds: nextS };
          }

          if (r1 && !r2 && !r3) {
            nextR = 6;
            nextS[2] = runnerSpeeds[1];
            nextS[1] = batterSpd;
            return { runs: runs, outsAdded: 0, nextRunners: nextR, nextRunnerSpeeds: nextS };
          }

          if (!r1 && r2 && !r3) {
            nextR = 6;
            nextS[2] = runnerSpeeds[2];
            nextS[1] = batterSpd;
            return { runs: runs, outsAdded: 0, nextRunners: nextR, nextRunnerSpeeds: nextS };
          }

          if (!r1 && !r2 && r3) {
            nextR = 5;
            nextS[3] = runnerSpeeds[3];
            nextS[1] = batterSpd;
            return { runs: runs, outsAdded: 0, nextRunners: nextR, nextRunnerSpeeds: nextS };
          }

          nextR = 4;
          nextS[1] = batterSpd;
          return { runs: runs, outsAdded: 0, nextRunners: nextR, nextRunnerSpeeds: nextS };
        }

        return { runs: 0, outsAdded: 0, nextRunners: runners, nextRunnerSpeeds: runnerSpeeds };
      }

      function advOnBIPOut(runners, event, batterSpd, runnerSpeeds, outs, isEndRun, endrunSkill, pitcherLevel, rnd) {
        const r1 = (runners & 4) !== 0;
        const r2 = (runners & 2) !== 0;
        const r3 = (runners & 1) !== 0;

        let runs = 0;
        let outsAdded = 1;

        let nextR = runners;
        let nextS = Object.assign({}, runnerSpeeds);

        const target = isEndRun ? chooseStealTarget(runners) : null;

        function maybeDoubleOff(baseFrom, spd, baseProb) {
          let p = baseProb;
          if (spd === 'fast') p -= 0.04;
          if (spd === 'slow') p += 0.05;
          if (endrunSkill === 'low') p += 0.03;
          p = clamp(p, 0.02, 0.40);
          if (rnd() < p) {
            outsAdded = 2;
            nextR = nextR & ~((baseFrom === 1) ? 4 : (baseFrom === 2 ? 2 : 1));
            delete nextS[baseFrom];
            return true;
          }
          return false;
        }

        if (isEndRun && target) {
          if (event === 'LD') {
            const spd = runnerSpeeds[target.baseFrom];
            if (maybeDoubleOff(target.baseFrom, spd, 0.12)) {
              return { runs: 0, outsAdded: outsAdded, nextRunners: nextR, nextRunnerSpeeds: nextS };
            }
            return { runs: 0, outsAdded: 1, nextRunners: runners, nextRunnerSpeeds: runnerSpeeds };
          }

          if (event === 'FB') {
            const spd = runnerSpeeds[target.baseFrom];
            if (maybeDoubleOff(target.baseFrom, spd, 0.05)) {
              return { runs: 0, outsAdded: outsAdded, nextRunners: nextR, nextRunnerSpeeds: nextS };
            }
            return { runs: 0, outsAdded: 1, nextRunners: runners, nextRunnerSpeeds: runnerSpeeds };
          }

          if (event === 'GB') {
            const spdRunner = runnerSpeeds[target.baseFrom];
            const spdB = batterSpd;

            let pFC = (target.baseFrom === 2) ? 0.28 : 0.40;
            if (spdRunner === 'fast') pFC -= 0.08;
            if (spdRunner === 'slow') pFC += 0.10;
            if (spdB === 'fast') pFC -= 0.04;
            if (spdB === 'slow') pFC += 0.05;
            pFC = clamp(pFC, 0.10, 0.65);

            if (rnd() < pFC) {
              let newR = runners & ~((target.baseFrom === 1) ? 4 : 2);
              let newS = Object.assign({}, runnerSpeeds);
              delete newS[target.baseFrom];

              newR |= 4;
              newS[1] = batterSpd;

              return { runs: 0, outsAdded: 1, nextRunners: newR, nextRunnerSpeeds: newS };
            }

            let newR = runners & ~((target.baseFrom === 1) ? 4 : 2);
            let newS = Object.assign({}, runnerSpeeds);
            delete newS[target.baseFrom];

            newR |= (target.baseTo === 2) ? 2 : 1;
            newS[target.baseTo] = spdRunner;

            return { runs: 0, outsAdded: 1, nextRunners: newR, nextRunnerSpeeds: newS };
          }
        }

        if (event === 'LD') {
          return { runs: 0, outsAdded: 1, nextRunners: runners, nextRunnerSpeeds: runnerSpeeds };
        }

        if (event === 'FB') {
          let newR = runners;
          let newS = Object.assign({}, runnerSpeeds);

          if (r3 && outs < 2) {
            let p = 0.52;
            if (runnerSpeeds[3] === 'fast') p += 0.10;
            if (runnerSpeeds[3] === 'slow') p -= 0.12;
            p = clamp(p, 0.10, 0.90);

            if (rnd() < p) {
              runs += 1;
              newR = newR & ~1;
              delete newS[3];
            }
          }

          if ((newR & 1) === 0 && r2 && outs < 2) {
            let p = 0.18;
            if (runnerSpeeds[2] === 'fast') p += 0.06;
            if (runnerSpeeds[2] === 'slow') p -= 0.05;
            p = clamp(p, 0.02, 0.40);
            if (rnd() < p) {
              newR = (newR & ~2) | 1;
              newS[3] = runnerSpeeds[2];
              delete newS[2];
            }
          }

          return { runs: runs, outsAdded: 1, nextRunners: newR, nextRunnerSpeeds: newS };
        }

        if (event === 'GB') {
          let dpProb = 0.0;

          if (r1 && outs < 2) {
            dpProb = 0.22;
            if (batterSpd === 'fast') dpProb -= 0.08;
            if (batterSpd === 'slow') dpProb += 0.06;
            if (runnerSpeeds[1] === 'fast') dpProb -= 0.04;
            if (runnerSpeeds[1] === 'slow') dpProb += 0.05;
            dpProb = clamp(dpProb, 0.05, 0.45);
          }

          if (r1 && outs < 2 && rnd() < dpProb) {
            let newR = runners & ~4;
            let newS = Object.assign({}, runnerSpeeds);
            delete newS[1];

            if (((newR & 1) === 0) && r2) {
              let p = 0.20;
              if (runnerSpeeds[2] === 'fast') p += 0.05;
              if (runnerSpeeds[2] === 'slow') p -= 0.04;
              p = clamp(p, 0.05, 0.35);
              if (rnd() < p) {
                newR = (newR & ~2) | 1;
                newS[3] = runnerSpeeds[2];
                delete newS[2];
              }
            }

            return { runs: 0, outsAdded: 2, nextRunners: newR, nextRunnerSpeeds: newS };
          }

          let newR = runners;
          let newS = Object.assign({}, runnerSpeeds);

          if (r3 && outs < 2) {
            let p = (outs === 1) ? 0.08 : 0.03;
            if (runnerSpeeds[3] === 'fast') p += 0.03;
            if (runnerSpeeds[3] === 'slow') p -= 0.02;
            p = clamp(p, 0.00, 0.20);
            if (rnd() < p) {
              runs += 1;
              newR = newR & ~1;
              delete newS[3];
            }
          }

          if ((newR & 1) === 0 && r2) {
            let p = (outs === 0) ? 0.55 : 0.40;
            if (runnerSpeeds[2] === 'fast') p += 0.07;
            if (runnerSpeeds[2] === 'slow') p -= 0.06;
            p = clamp(p, 0.05, 0.90);
            if (rnd() < p) {
              newR = (newR & ~2) | 1;
              newS[3] = runnerSpeeds[2];
              delete newS[2];
            }
          }

          if ((newR & 2) === 0 && r1) {
            let p = (outs === 0) ? 0.60 : 0.45;
            if (runnerSpeeds[1] === 'fast') p += 0.06;
            if (runnerSpeeds[1] === 'slow') p -= 0.05;
            p = clamp(p, 0.05, 0.95);
            if (rnd() < p) {
              newR = (newR & ~4) | 2;
              newS[2] = runnerSpeeds[1];
              delete newS[1];
            }
          }

          return { runs: runs, outsAdded: 1, nextRunners: newR, nextRunnerSpeeds: newS };
        }

        return { runs: 0, outsAdded: 1, nextRunners: runners, nextRunnerSpeeds: runnerSpeeds };
      }

      function applyBuntSuccess(runners, runnerSpeeds) {
        const r1 = (runners & 4) !== 0;
        const r2 = (runners & 2) !== 0;
        const r3 = (runners & 1) !== 0;

        let newR = runners;
        let newS = Object.assign({}, runnerSpeeds);

        if (r2 && !r3) {
          newR = (newR & ~2) | 1;
          newS[3] = newS[2];
          delete newS[2];
        }

        if (r1 && ((newR & 2) === 0)) {
          newR = (newR & ~4) | 2;
          newS[2] = newS[1];
          delete newS[1];
        }

        return { nextRunners: newR, nextRunnerSpeeds: newS };
      }

      function applySqueeze(runners, runnerSpeeds) {
        const r1 = (runners & 4) !== 0;
        const r2 = (runners & 2) !== 0;
        const r3 = (runners & 1) !== 0;

        let runs = 0;
        let newR = runners;
        let newS = Object.assign({}, runnerSpeeds);

        if (r3) {
          runs += 1;
          newR = newR & ~1;
          delete newS[3];
        }

        if (r2) {
          newR = (newR & ~2) | 1;
          newS[3] = newS[2];
          delete newS[2];
        }

        if (r1) {
          newR = (newR & ~4) | 2;
          newS[2] = newS[1];
          delete newS[1];
        }

        return { runs: runs, nextRunners: newR, nextRunnerSpeeds: newS };
      }

      function simulateInning(startOuts, startRunners, initialRunnerSpeeds, firstAction, lineupData, startIndex, pitcherLevel, endrunSkill, rnd) {
        let outs = startOuts;
        let runners = startRunners;
        let totalRuns = 0;

        let idx = startIndex;
        let first = true;

        let runnerSpeeds = Object.assign({}, initialRunnerSpeeds);

        while (outs < 3) {
          const batter = lineupData[idx];
          const isEndRun = first && firstAction.type === 'endrun';

          const probs = makeBatterProbs(batter, pitcherLevel, isEndRun, endrunSkill);

          if (first) {
            first = false;

            if (firstAction.type === 'bunt') {
              if (rnd() < firstAction.rate) {
                const a = applyBuntSuccess(runners, runnerSpeeds);
                outs += 1;
                runners = a.nextRunners;
                runnerSpeeds = a.nextRunnerSpeeds;
                idx = (idx + 1) % 9;
                continue;
              } else {
                outs += 1;
                idx = (idx + 1) % 9;
                continue;
              }
            }

            if (firstAction.type === 'steal') {
              const target = chooseStealTarget(runners);
              if (target) {
                const baseRate = firstAction.rate;
                const runSpd = runnerSpeeds[target.baseFrom];
                const p = stealSuccessProb(baseRate, runSpd, pitcherLevel);

                if (rnd() < p) {
                  runners = (runners & ~target.bitFrom) | target.bitTo;
                  const newS = Object.assign({}, runnerSpeeds);
                  newS[target.baseTo] = newS[target.baseFrom];
                  delete newS[target.baseFrom];
                  runnerSpeeds = newS;
                  continue;
                } else {
                  outs += 1;
                  runners = (runners & ~target.bitFrom);
                  const newS = Object.assign({}, runnerSpeeds);
                  delete newS[target.baseFrom];
                  runnerSpeeds = newS;
                  continue;
                }
              }
            }

            if (firstAction.type === 'squeeze') {
              if (rnd() < firstAction.rate) {
                const a = applySqueeze(runners, runnerSpeeds);
                totalRuns += a.runs;
                outs += 1;
                runners = a.nextRunners;
                runnerSpeeds = a.nextRunnerSpeeds;
                idx = (idx + 1) % 9;
                continue;
              } else {
                outs += 1;
                runners = (runners & ~1);
                const newS = Object.assign({}, runnerSpeeds);
                delete newS[3];
                runnerSpeeds = newS;
                idx = (idx + 1) % 9;
                continue;
              }
            }
          }

          const ev = pick(probs, rnd);

          if (ev === 'HR' || ev === '3B' || ev === '2B' || ev === '1B' || ev === 'BB') {
            const res = advOnHit(runners, ev, batter.spd, runnerSpeeds, outs, isEndRun, rnd);
            totalRuns += res.runs;
            outs += res.outsAdded;
            runners = res.nextRunners;
            runnerSpeeds = res.nextRunnerSpeeds;
            idx = (idx + 1) % 9;
            continue;
          }

          if (ev === 'K') {
            if (isEndRun) {
              const target = chooseStealTarget(runners);
              if (target) {
                const runSpd = runnerSpeeds[target.baseFrom];
                const caughtProb = endrunCaughtProb(target, runSpd, pitcherLevel, endrunSkill);
                if (rnd() < caughtProb) {
                  outs += 2;
                  runners = runners & ~target.bitFrom;
                  const newS = Object.assign({}, runnerSpeeds);
                  delete newS[target.baseFrom];
                  runnerSpeeds = newS;
                } else {
                  outs += 1;
                  runners = (runners & ~target.bitFrom) | target.bitTo;
                  const newS = Object.assign({}, runnerSpeeds);
                  newS[target.baseTo] = newS[target.baseFrom];
                  delete newS[target.baseFrom];
                  runnerSpeeds = newS;
                }
                idx = (idx + 1) % 9;
                continue;
              }
            }

            outs += 1;
            idx = (idx + 1) % 9;
            continue;
          }

          if (ev === 'GB' || ev === 'FB' || ev === 'LD') {
            const res = advOnBIPOut(runners, ev, batter.spd, runnerSpeeds, outs, isEndRun, endrunSkill, pitcherLevel, rnd);
            totalRuns += res.runs;
            outs += res.outsAdded;
            runners = res.nextRunners;
            runnerSpeeds = res.nextRunnerSpeeds;
            idx = (idx + 1) % 9;
            continue;
          }

          outs += 1;
          idx = (idx + 1) % 9;
        }

        return totalRuns;
      }

      self.onmessage = function(e) {
        const iter = e.data.iter;
        const startOuts = e.data.startOuts;
        const startRunners = e.data.startRunners;
        const initialRunnerSpeeds = e.data.initialRunnerSpeeds;
        const strategies = e.data.strategies;
        const lineupData = e.data.lineupData;
        const currentIdx = e.data.currentIdx;
        const pitcherLevel = e.data.pitcherLevel;
        const endrunSkill = e.data.endrunSkill;

        const seedBase = (Date.now() ^ (startRunners * 131) ^ (startOuts * 911) ^ (currentIdx * 1777)) >>> 0;
        const rnd = mulberry32(seedBase);

        const cap = 24;
        const totalSteps = iter * strategies.length;
        let done = 0;

        const progressEvery = Math.max(50000, Math.floor(totalSteps / 600));
        const results = {};

        for (let s = 0; s < strategies.length; s++) {
          const st = strategies[s];
          const dist = new Array(cap + 1).fill(0);
          let sumRuns = 0;

          for (let i = 0; i < iter; i++) {
            const r = simulateInning(startOuts, startRunners, initialRunnerSpeeds, st, lineupData, currentIdx, pitcherLevel, endrunSkill, rnd);
            sumRuns += r;
            dist[Math.min(r, cap)] += 1;

            done += 1;
            if (done % progressEvery === 0) {
              self.postMessage({ type: 'progress', done: done, totalSteps: totalSteps });
            }
          }

          const expectancy = sumRuns / iter;
          const scoreProb = 1.0 - (dist[0] / iter);
          const exact1 = (dist[1] || 0) / iter;
          const exact2 = (dist[2] || 0) / iter;
          const exact3 = (dist[3] || 0) / iter;
          const exact4 = (dist[4] || 0) / iter;

          results[st.id] = {
            name: st.name,
            expectancy: expectancy,
            scoreProb: scoreProb,
            exact1: exact1,
            exact2: exact2,
            exact3: exact3,
            exact4: exact4
          };
        }

        self.postMessage({ type: 'done', results: results });
      };
    `;

    const blob = new Blob([workerCode], { type: "application/javascript" });
    const url = URL.createObjectURL(blob);
    return new Worker(url);
  }

  function runSimulation() {
    const btn = document.getElementById("calcBtn");
    const loading = document.getElementById("loading");
    const progressWrap = document.getElementById("progressWrap");
    const progressBar = document.getElementById("progressBar");
    const progressText = document.getElementById("progressText");

    if (activeWorker) {
      try { activeWorker.terminate(); } catch (e) {}
      activeWorker = null;
    }

    btn.disabled = true;
    loading.style.display = "block";
    progressWrap.style.display = "block";
    progressText.style.display = "block";
    progressBar.style.width = "0%";
    progressText.textContent = "進捗 0%";

    const lineupData = readLineupNormalized();

    const iter = parseInt(document.getElementById("simCount").value, 10);
    const startOuts = parseInt(document.getElementById("outs").value, 10);
    const startRunners = runnersStrToBits(document.getElementById("runnersScenario").value);
    const currentIdx = parseInt(document.getElementById("currentBatterIndex").value, 10);
    const pitcherLevel = document.getElementById("pitcherLevel").value;
    const endrunSkill = document.getElementById("endrunSkill").value;

    let initialRunnerSpeeds = {};
    if (startRunners & 4) {
      const idx = parseInt(document.getElementById("runner1_idx").value, 10);
      initialRunnerSpeeds[1] = lineupData[idx].spd;
    }
    if (startRunners & 2) {
      const idx = parseInt(document.getElementById("runner2_idx").value, 10);
      initialRunnerSpeeds[2] = lineupData[idx].spd;
    }
    if (startRunners & 1) {
      const idx = parseInt(document.getElementById("runner3_idx").value, 10);
      initialRunnerSpeeds[3] = lineupData[idx].spd;
    }

    const strategies = buildStrategies(startOuts, startRunners);

    if (strategies.length === 1) {
      document.getElementById("output").innerHTML = `
        <div class="title">分析結果</div>
        <div style="padding:10px; font-size:13px; opacity:0.85; line-height:1.7;">
          今の状況だと強攻以外が条件に合わないか成功率が0なので分析対象は強攻だけです。<br>
          送りバントや盗塁やスクイズを出したい場合は成功率を0より大きくして条件に合う塁状況とアウト数にしてください。
        </div>
      `;
      btn.disabled = false;
      loading.style.display = "none";
      progressWrap.style.display = "none";
      progressText.style.display = "none";
      return;
    }

    activeWorker = createSimWorker();

    activeWorker.onmessage = (ev) => {
      const msg = ev.data;

      if (msg.type === "progress") {
        const pct = Math.max(0, Math.min(100, (msg.done / msg.totalSteps) * 100));
        progressBar.style.width = pct.toFixed(1) + "%";
        progressText.textContent = "進捗 " + pct.toFixed(1) + "%";
        return;
      }

      if (msg.type === "done") {
        const results = msg.results;

        let html = "";

        html += `<div style="margin-bottom:20px;">
          <div class="title">得点期待値と得点確率</div>
          <table class="result-table">
            <tr>
              <th>戦術</th>
              <th>得点期待値</th>
              <th>得点確率</th>
            </tr>`;

        strategies.forEach(st => {
          const d = results[st.id];
          html += `<tr>
            <td style="text-align:left;">${d.name}</td>
            <td>${d.expectancy.toFixed(3)}</td>
            <td>${(d.scoreProb * 100).toFixed(2)}%</td>
          </tr>`;
        });

        html += `</table>
          <div class="mini">得点確率はこの回の攻撃で1点以上取る確率です</div>
        </div>`;

        function bestIdBy(key) {
          let bestId = strategies[0].id;
          let bestVal = -1;
          strategies.forEach(st => {
            const v = results[st.id][key];
            if (v > bestVal) { bestVal = v; bestId = st.id; }
          });
          return bestId;
        }

        const best1 = bestIdBy("exact1");
        const best2 = bestIdBy("exact2");
        const best3 = bestIdBy("exact3");
        const best4 = bestIdBy("exact4");

        html += `<div class="title">目標得点別の推奨戦術</div>`;
        html += `<div class="table-scroll"><table class="result-table">
          <thead>
            <tr>
              <th>目標</th>
              <th>推奨戦術</th>
              ${strategies.map(s => `<th>${s.name}</th>`).join("")}
            </tr>
          </thead>
          <tbody>`;

        html += `<tr>
          <td style="font-weight:bold;">1点だけ 確率</td>
          <td>${results[best1].name}</td>
          ${strategies.map(st => `<td>${(results[st.id].exact1 * 100).toFixed(2)}%</td>`).join("")}
        </tr>`;

        html += `<tr>
          <td style="font-weight:bold;">2点だけ 確率</td>
          <td>${results[best2].name}</td>
          ${strategies.map(st => `<td>${(results[st.id].exact2 * 100).toFixed(2)}%</td>`).join("")}
        </tr>`;

        html += `<tr>
          <td style="font-weight:bold;">3点だけ 確率</td>
          <td>${results[best3].name}</td>
          ${strategies.map(st => `<td>${(results[st.id].exact3 * 100).toFixed(2)}%</td>`).join("")}
        </tr>`;

        html += `<tr>
          <td style="font-weight:bold;">4点だけ 確率</td>
          <td>${results[best4].name}</td>
          ${strategies.map(st => `<td>${(results[st.id].exact4 * 100).toFixed(2)}%</td>`).join("")}
        </tr>`;

        html += `</tbody></table></div>`;

        document.getElementById("output").innerHTML = html;

        btn.disabled = false;
        loading.style.display = "none";
        progressWrap.style.display = "none";
        progressText.style.display = "none";

        try { activeWorker.terminate(); } catch (e) {}
        activeWorker = null;
      }
    };

    activeWorker.onerror = () => {
      btn.disabled = false;
      loading.style.display = "none";
      progressWrap.style.display = "none";
      progressText.style.display = "none";
      document.getElementById("output").innerHTML = `
        <div class="title">分析結果</div>
        <div style="padding:10px; font-size:13px; opacity:0.85; line-height:1.7;">
          実行中にエラーが発生しました。回数を減らして再実行してください。
        </div>
      `;
      try { activeWorker.terminate(); } catch (e) {}
      activeWorker = null;
    };

    activeWorker.postMessage({
      iter: iter,
      startOuts: startOuts,
      startRunners: startRunners,
      initialRunnerSpeeds: initialRunnerSpeeds,
      strategies: strategies,
      lineupData: lineupData,
      currentIdx: currentIdx,
      pitcherLevel: pitcherLevel,
      endrunSkill: endrunSkill
    });
  }

  document.getElementById("calcBtn").addEventListener("click", runSimulation);
  document.getElementById("currentBatterIndex").addEventListener("change", function() {
    highlightCurrentBatter();
    updateRunnerSelectVisibility();
  });
  document.getElementById("runnersScenario").addEventListener("change", updateRunnerSelectVisibility);
  document.getElementById("outs").addEventListener("change", updateAvailabilityOnly);
  document.getElementById("batterMode").addEventListener("change", function() {
    renderLineupTable();
  });

  renderLineupTable();
  highlightCurrentBatter();
  updateRunnerSelectVisibility();
  updateAvailabilityOnly();
  updateBatterModeHint();
  updateEndrunNote();
</script>
</body>
</html>
